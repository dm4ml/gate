{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>GATE is a Python module that detects drift in partitions of data. GATE computes partition summaries, which are then fed into an anomaly detection algorithm to detect whether a new partition is anomalous. This minimizes false positive alerts when detecting drift in machine learning (ML) pipelines, where there may be many features and prediction columns.</p>"},{"location":"#installation","title":"Installation","text":"<p>GATE is available on PyPI and can be installed with pip:</p> <pre><code>pip install gate-drift\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>GATE is designed to be used with Pandas dataframes. Check out the example for a walkthrough of how to use GATE.</p>"},{"location":"#research-contributions","title":"Research Contributions","text":"<p>GATE was developed and is maintained by researchers at the UC Berkeley EPIC Lab.</p> <p>An initial version of GATE was developed as part of a collaboration with Meta, and the research paper, \"Moving Fast With Broken Data\" by Shankar et al., is available on arXiv. This module slightly differs from the original implementation, but the core ideas around partition summaries and anomaly detection are the same.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#gate.summarize.summarize","title":"<code>summarize(df, columns=[], embedding_column_map={}, partition_key='', previous_summaries=[])</code>","text":"<p>This function computes partition-wide summary statistics for the given columns. df can have multiple partitions.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Dataframe to summarize.</p> required <code>columns</code> <code>typing.List[str]</code> <p>List of columns to generate summary statistics for. Must be a subset of df.columns. If empty, previous_summaries must not be empty.</p> <code>[]</code> <code>embedding_column_map</code> <code>typing.Dict[str, str]</code> <p>Dictionary of embedding key to embedding value column. Keys and values must be in df.columns. If empty, previous_summaries must not be empty.</p> <code>{}</code> <code>partition_key</code> <code>str</code> <p>Name of column to partition the dataframe by. Must be in df. columns. Can be empty if no partitioning is desired, or if the dataframe represents a single partition. If empty, previous_summaries must not be empty.</p> <code>''</code> <code>previous_summaries</code> <code>typing.List[Summary]</code> <p>List of Summary objects representing previous partition summaries.</p> <code>[]</code> <p>Returns:</p> Type Description <code>typing.List[Summary]</code> <p>typing.List[Summary]: List of Summary objects, one per distinct partition found in df.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>partition_key</code> is \"group\".</p> <code>ValueError</code> <p>If <code>columns is empty</code> and <code>previous_summaries</code> is empty.</p> <code>ValueError</code> <p>If <code>partition_key</code>is empty and <code>previous_summaries</code> is empty.</p> <code>ValueError</code> <p>If <code>partition_key</code> is not in <code>df.columns</code>.</p> <code>ValueError</code> <p>If any column in <code>columns</code> is not in <code>df.columns</code>.</p>"},{"location":"api/#gate.summarize.compute_embeddings","title":"<code>compute_embeddings(column, column_type)</code>","text":"<p>Computes embeddings for a Series with the huggingface/transformers library. We use the clip-ViT-B-32 model. This is an optional function; we recommend you compute embeddings yourself.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>pd.Series</code> <p>Series to compute embeddings for. Must be of string type. Can contain either paths to files or text.</p> required <code>column_type</code> <code>str</code> <p>Type of the column. Must be \"text\" or \"image\".</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>pd.Series: Series of embeddings to add to your DataFrame.</p>"},{"location":"api/#gate.summary.Summary","title":"<code>Summary</code>","text":""},{"location":"api/#gate.summary.Summary.summary","title":"<code>summary: pd.DataFrame</code>  <code>property</code>","text":"<p>Dataframe containing the summary statistics.</p>"},{"location":"api/#gate.summary.Summary.embeddings_summary","title":"<code>embeddings_summary: pd.DataFrame</code>  <code>property</code>","text":"<p>Dataframe containing the embeddings summary statistics if there are embeddings, otherwise None.</p>"},{"location":"api/#gate.summary.Summary.partition_key","title":"<code>partition_key: str</code>  <code>property</code>","text":"<p>Partition key column.</p>"},{"location":"api/#gate.summary.Summary.partition","title":"<code>partition: str</code>  <code>property</code>","text":"<p>Partition value.</p>"},{"location":"api/#gate.summary.Summary.columns","title":"<code>columns: typing.List[str]</code>  <code>property</code>","text":"<p>Columns for which summary statistics were computed.</p>"},{"location":"api/#gate.summary.Summary.non_embedding_columns","title":"<code>non_embedding_columns: typing.List[str]</code>  <code>property</code>","text":"<p>Columns for which summary statistics were computed. Ignores embedding columns.</p>"},{"location":"api/#gate.summary.Summary.embedding_examples","title":"<code>embedding_examples(embedding_key_column)</code>","text":"<p>Returns examples in each embedding cluster for the given embedding key column.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_key_column</code> <code>str</code> <p>Column name representing the embedding key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no embedding examples.</p> <code>ValueError</code> <p>If the embedding key column does not exist.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Examples in each embedding cluster. Contains the columns partition_key, embedding_key_column, embedding_value_column, and cluster.</p>"},{"location":"api/#gate.summary.Summary.embedding_centroids","title":"<code>embedding_centroids(embedding_key_column)</code>","text":"<p>Returns embedding centroids for the given embedding key column.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_key_column</code> <code>str</code> <p>Column name representing the embedding key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no embedding examples.</p> <code>ValueError</code> <p>If the embedding key column does not exist.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Matrix of embedding centroids, size (num_clusters, embedding_dim).</p>"},{"location":"api/#gate.summary.Summary.statistics","title":"<code>statistics()</code>","text":"<p>Returns list of statistics computed for each column:</p> <ul> <li>coverage: Fraction of rows that are not null.</li> <li>mean: Mean of the column.</li> <li>p50: Median of the column.</li> <li>num_unique_values: Number of unique values in the column.</li> <li>occurrence_ratio: Ratio of the most common value to all other values.</li> <li>p95: 95th percentile of the column.</li> </ul>"},{"location":"api/#gate.summary.Summary.value","title":"<code>value()</code>","text":"<p>Combines the summary and embeddings summary into a single dataframe.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Summary including embeddings, if exists.</p>"},{"location":"api/#gate.summary.Summary.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the object's value (i.e., summary).</p> <p>Usage: <code>print(summary)</code></p>"},{"location":"api/#gate.drift.detect_drift","title":"<code>detect_drift(current_summary, previous_summaries, validity=[], cluster=True, k=3)</code>","text":"<p>Computes whether the current partition summary has drifted from previous summaries.</p> <p>Parameters:</p> Name Type Description Default <code>current_summary</code> <code>Summary</code> <p>Partition summary for current partition.</p> required <code>previous_summaries</code> <code>typing.List[Summary]</code> <p>Previous partition summaries.</p> required <code>validity</code> <code>typing.List[int]</code> <p>Indicator list identifying which partition summaries are valid. 1 if valid, 0 if invalid. If empty, we assume all partition summaries are valid. Must be empty or equal to length of previous_summaries.</p> <code>[]</code> <code>cluster</code> <code>bool</code> <p>Whether or not to cluster columns in summaries. Increases runtime but also increases precision in drift detection. Only engaged if summaries have more than 10 columns. Defaults to True.</p> <code>True</code> <code>k</code> <code>int</code> <p>Number of nearest neighbor partitions to inspect. Defaults to 3.</p> <code>3</code> <p>Returns (DriftResult): DriftResult object with score and score percentile.</p>"},{"location":"api/#gate.drift.DriftResult","title":"<code>DriftResult</code>","text":""},{"location":"api/#gate.drift.DriftResult.summary","title":"<code>summary: Summary</code>  <code>property</code>","text":"<p>Summary of the partition.</p>"},{"location":"api/#gate.drift.DriftResult.neighbor_summaries","title":"<code>neighbor_summaries: typing.List[Summary]</code>  <code>property</code>","text":"<p>Summaries of the nearest neighbors of the partition.</p>"},{"location":"api/#gate.drift.DriftResult.score","title":"<code>score: float</code>  <code>property</code>","text":"<p>Distance from the partition to its k nearest neighbors.</p>"},{"location":"api/#gate.drift.DriftResult.score_percentile","title":"<code>score_percentile: float</code>  <code>property</code>","text":"<p>Percentile of the partition's score in the distribution of all scores.</p>"},{"location":"api/#gate.drift.DriftResult.is_drifted","title":"<code>is_drifted: bool</code>  <code>property</code>","text":"<p>Indicates whether the partition is drifted or not, compared to previous partitions. This is determined by the percentile of the partition's score in the distribution of all scores. The threshold is 95%.</p>"},{"location":"api/#gate.drift.DriftResult.all_scores","title":"<code>all_scores: pd.Series</code>  <code>property</code>","text":"<p>Scores of all previous partitions.</p>"},{"location":"api/#gate.drift.DriftResult.clustering","title":"<code>clustering: typing.Dict[int, typing.List[str]]</code>  <code>property</code>","text":"<p>Clustering of the columns based on their partition summaries and meaning of column names (determined via embeddings). Returns a dictionary with cluster numbers as keys and lists of columns as values.</p>"},{"location":"api/#gate.drift.DriftResult.drifted_examples","title":"<code>drifted_examples(embedding_key_column)</code>","text":"<p>Returns some examples from the partition that are most drifted from nearest neighbors in the embedding space in previous partitions.</p> <p>Throws an error if the embedding_key_column isn't a valid embedding key column, or if there are no embedding columns.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_key_column</code> <code>str</code> <p>Column that represents the embedding key (e.g., text, image).</p> required <p>Returns:</p> Type Description <code>typing.Dict[str, pd.DataFrame]</code> <p>typing.Dict[str, pd.DataFrame]: Dictionary with two keys: \"drifted_examples\" and \"corresponding_examples\". The value of each key is a dataframe with columns \"partition_key\", \"embedding_key_column\", and \"embedding_value_column\".</p>"},{"location":"api/#gate.drift.DriftResult.drill_down","title":"<code>drill_down(sort_by_cluster_score=False, average_embedding_columns=True)</code>","text":"<p>Compute the columns with highest magnitude anomaly scores. Anomaly scores are computed as the z-score of the column with respect to previous partition summary statistics.</p> <p>The resulting dataframe has the following schema (column, statistic are indexes):</p> <ul> <li>column: Name of the column</li> <li>statistic: Name of the statistic</li> <li>z-score: z-score of the column</li> <li>cluster: Cluster number of the column (if clustering was performed)</li> <li>z-score-cluster: z-score of the column in the cluster (if clustering was performed)</li> </ul> <p>Use the <code>drifted_columns</code> method first, since <code>drifted_columns</code> deduplicates columns.</p> <p>Parameters:</p> Name Type Description Default <code>sort_by_cluster_score</code> <code>bool</code> <p>Whether to sort by cluster z-score. Defaults to False.</p> <code>False</code> <code>average_embedding_columns</code> <code>bool</code> <p>Whether to average statistics across embedding dimensions. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Dataframe with columns with highest magnitude anomaly scores. Sorted by the magnitude of the z-score for a column. If clustering was performed, the dataframe will be sorted by the magnitude of the z-score in the cluster before the column score.</p>"},{"location":"api/#gate.drift.DriftResult.drifted_columns","title":"<code>drifted_columns(limit=10, average_embedding_columns=True)</code>","text":"<p>Returns the top limit columns that have drifted. The resulting dataframe has the following schema (column is an index):</p> <ul> <li>column: Name of the column</li> <li>statistic: Name of the statistic</li> <li>z-score: z-score of the column</li> <li>cluster: Cluster number of the column (if clustering was performed)</li> <li>z-score-cluster: z-score of the column in the cluster (if clustering was performed)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Limit for number of drifted columns to return. Defaults to 10.</p> <code>10</code> <code>average_embedding_columns</code> <code>bool</code> <p>Whether to average statistics across embedding dimensions. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Dataframe with columns with highest magnitude z-scores. If clustering was performed, the dataframe will also contain the z-score in the cluster and the cluster number. Each column is deduplicated, so only the statistic with the highest magnitude z-score is returned.</p>"},{"location":"api/#gate.drift.DriftResult.__str__","title":"<code>__str__()</code>","text":"<p>Prints the drift score, percentile, and the top drifted columns.</p>"},{"location":"api/#gate.statistics.type_to_statistics","title":"<code>type_to_statistics(t)</code>","text":"<p>Returns the statistics that are computed for a given type.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Type (one of \"int\", \"float\", \"string\", \"embedding\").</p> required <p>Returns:</p> Type Description <code>typing.List[str]</code> <p>typing.List[str]: List of statistics that are computed for the type. Partition summaries will have NaNs for statistics that are not computed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type is unknown.</p>"},{"location":"embedding/","title":"Drift Detection on Embeddings","text":"<p>GATE supports drift detection and debugging of embeddings, in addition to structured data. At a high level, embeddings are represented in their own column, and you can call <code>summarize</code> and <code>detect_drift</code> on dataframes with embedding columns.</p>"},{"location":"embedding/#embedding-key-and-value-columns","title":"Embedding key and value columns","text":"<p>In your original dataframe, you should have a column that contains the embedding key, and a column that contains the embedding value. The key column should be a string (e.g., text, filename), and the value column should be a list of floats. For example:</p> <pre><code>df = pd.DataFrame(\n    {\n        \"date\": [\"2020-01-01\", \"2020-01-01\", \"2020-01-01\"], # This is the partition key\n        \"text\": [\"hello world!\", \"goodbye\", \"a third greeting\"],\n        \"embedding\": [\n            [0.1, 0.2, 0.3], # Imagine this is the embedding for \"hello world!\"\n            [0.4, 0.5, 0.6], # Imagine this is the embedding for \"goodbye\"\n            [0.7, 0.8, 0.9], # Imagine this is the embedding for \"a third greeting\"\n        ],\n    }\n)\n</code></pre> <p>Then, when calling <code>summarize</code> on your dataframe, you can specify the embedding key-value pairs as follows:</p> <pre><code>from gate import summarize\n\nsummarize(\n    df,\n    partition_key=\"date\",\n    embedding_column_map={\"text\": \"embedding\"},\n)\n</code></pre> <p>Both keys and values in <code>embedding_column_map</code> should be strings, representing column names in your dataframe.</p>"},{"location":"embedding/#summarizing-embeddings","title":"Summarizing embeddings","text":"<p>When you call <code>summarize</code> on a dataframe with embedding columns, GATE will automatically compute summary statistics for each dimension in the embedding values. You can access these summaries by calling <code>embeddings_summary</code> on the returned <code>Summary</code> object.</p> <p>GATE will also cluster the embeddings, compute centroids for each cluster, and store examples for each cluster. Embeddings are clustered for each embedding column separately. You can access the examples by calling <code>embedding_examples</code> on the returned <code>Summary</code> object. You can access the centroids by calling <code>embedding_centroids</code> on the returned <code>Summary</code> object.</p> <pre><code>from gate import summarize\n\nsummaries = summarize(\n    df,\n    partition_key=\"date\",\n    columns=[], # No structured columns\n    embedding_column_map={\"text\": \"embedding\"},\n) # (1)!\n\n# Get the summary statistics for the embedding values\nsummaries[0].embeddings_summary\n\n# Get the examples for each cluster\nsummaries[0].embedding_examples(\"text\") # Must passing embedding key\n\n# Get the centroids for each cluster\nsummaries[0].embedding_centroids(\"text\") # Must passing embedding key\n</code></pre> <ol> <li>Note that <code>summarize</code> returns a list of <code>Summary</code> objects, one for each partition key. In this example, we only have one partition key, so we access the first element of the list.</li> </ol> <p>In practice, you probably won't need to call <code>embedding_examples</code> or <code>embedding_centroids</code> directly. These methods are used in <code>detect_drift</code>, as described below.</p>"},{"location":"embedding/#detecting-drift-on-embeddings","title":"Detecting drift on embeddings","text":"<p>You can call <code>detect_drift</code> on summaries of dataframes with embedding columns. Drift detection takes both structured column data and embeddings into consideration, if you have both.</p> <p><code>detect_drift</code> will return a <code>DriftResult</code> object, which contains the following information relevant to embeddings:</p> <ul> <li><code>drifted_columns</code>: Returns a dataframe of column names that have drifted, their most anomalous statistic (e.g., coverage), and the z-score. This includes both structured columns and embedding columns.</li> <li><code>drifted_examples</code>: Returns examples that have drifted most from their historical clusters. This is specific to embeddings. The object returned is a dictionary with <code>drifted_examples</code> and <code>corresponding_examples</code> keys. The value of each key is a dataframe with columns <code>partition_key</code>, <code>embedding_key_column</code>, and <code>embedding_value_column</code>.</li> </ul> <p>An example of calling <code>detect_drift</code> on a dataframe with embedding columns is shown below:</p> <pre><code>from gate import detect_drift\n\ndrift_result = detect_drift(\n    summary,\n    previous_summaries\n)\n\n# Get the drifted columns\ndrift_result.drifted_columns()\n\n# Get the drifted examples\ndrifted_example_result = drift_result.drifted_examples(\"text\") # Must passing embedding key\ndrifted_example_result[\"drifted_examples\"]\n</code></pre>"},{"location":"embedding/#real-dataset-example","title":"Real Dataset Example","text":"<p>For an example of using GATE with embeddings, see this example notebook in the Github repository.</p>"},{"location":"example/","title":"Example","text":"<p>There are two functions exposed by the GATE module: <code>summarize</code> and <code>detect_drift</code>. <code>summarize</code> computes partition summaries for a dataframe, and <code>detect_drift</code> detects whether a new partition is drifted. </p> <p>In this example, we'll demonstrate how to use GATE to detect drift in small synthetic dataset. </p>"},{"location":"example/#dataset-creation","title":"Dataset Creation","text":"<p>Our synthetic dataset will be created in Pandas. The partition key will be <code>date</code>. There will be 10 partitions, and each partition will have 10,000 rows. There will be 3 columns. The last partition will have a different column distribution than the first 9 partitions.</p> <pre><code>import numpy as np\nimport pandas as pd\n\n# create example date range\ndate_range = pd.date_range(start=\"2022-01-01\", periods=10, freq=\"D\")\n\n# create example data for each column\nint_col = np.random.randint(low=0, high=10, size=10000)\nfloat_col = np.random.normal(loc=0, scale=1, size=10000)\nstring_col = np.random.choice([\"A\", \"B\", \"C\"], size=10000)\n\n# combine data into a DataFrame\ndf_elems = []\nfor date in date_range:\n    date_data = {\"date\": date}\n    if date != date_range[-1]:\n        date_data = pd.DataFrame(\n            {\n                \"date\": [date] * len(int_col),\n                \"int_col\": int_col,\n                \"float_col\": float_col,\n                \"string_col\": string_col,\n            }\n        )\n    else:\n        # Change the distribution of the int column\n        date_data = pd.DataFrame(\n            {\n                \"date\": [date] * len(int_col),\n                \"int_col\": np.random.randint(low=10, high=20, size=10000),\n                \"float_col\": float_col,\n                \"string_col\": string_col\n            }\n        )\n    df_elems.append(date_data)\n\ndf = pd.concat(df_elems).reset_index(drop=True)\n</code></pre>"},{"location":"example/#summarize","title":"<code>summarize</code>","text":"<p>The <code>summarize</code> function computes partition summaries for a dataframe. In addition to a Pandas dataframe of raw data, it accepts the partition key and a list of columns in the dataframe to compute statistics for. Or, one can specify a list of previous partition summaries instead of the partition key and column list, and GATE will infer the partition key and columns from the previous partition summaries.</p> <p>The <code>summarize</code> function returns a list of <code>Summary</code> objects. Each <code>Summary</code> object contains the partition summary and other metadata, and has a <code>__str__</code> method that prints the summary in a human-readable format.</p> <pre><code>from gate import summarize\n\nsummaries = summarize(\n    df, partition_key=\"date\", columns=[\"int_col\", \"float_col\", \"string_col\"]\n)\n# len(summaries) == 10 because there are 10 distinct partitions\n\nprint(summaries[-1])\n\n\"\"\"\n        date      column  coverage       mean  num_unique_values  occurrence_ratio        p50        p95\n0 2022-01-10   float_col       1.0   0.015739                NaN               NaN   0.019152   1.665352\n1 2022-01-10     int_col       1.0  14.520700               10.0            0.1032  15.000000  19.000000\n2 2022-01-10  string_col       1.0        NaN                3.0            0.3411        NaN        NaN\n\"\"\"\n</code></pre> <p>Note</p> <p>You can access the summary data as a Pandas dataframe with the <code>value</code> attribute of the <code>Summary</code> object (i.e., <code>summaries[-1].summary</code>).</p>"},{"location":"example/#detect_drift","title":"<code>detect_drift</code>","text":"<p>The <code>detect_drift</code> function detects whether a new partition is drifted. It accepts a new partition summary and list of previous partition summaries and returns a <code>DriftResult</code> object. The <code>DriftResult</code> object has a <code>__str__</code> method that prints the drift result in a human-readable format.</p> <pre><code>from gate import detect_drift\n\ndrift_result = detect_drift(summaries[-1], summaries[:-1])\nprint(drift_result)\n\n\"\"\"\nDrift score: 6.3246 (100.00% percentile)\nTop drifted columns:\n           statistic   z-score\ncolumn                        \nint_col          p95  2.846050\nfloat_col        p95  0.000002\nstring_col  coverage  0.000000\n\"\"\"\n</code></pre> <p>The z-score represents the number of standard deviations away from the mean that the new partition is. In this case, the int col correctly has a high z-score. We recommend focusing on z-scores &gt; 2.5 or &lt; -2.5 when looking for drift.</p> <p>If you want to cluster correlated columns, you can pass <code>cluster = True</code> into <code>detect_drift</code>. The <code>DriftResult</code> object has a <code>clustering</code> attribute that contains the clusters.</p> <p>Note</p> <p>The list of previous partition summaries must have at least one element. Best results are achieved when there are at least 5 previous partition summaries.</p>"},{"location":"example/#real-dataset-example","title":"Real Dataset Example","text":"<p>For an end-to-end example on a real weather dataset, see the example notebook in the Github repository.</p> <p>For an example of using GATE with embeddings, see this example notebook in the Github repository.</p>"},{"location":"how-it-works/","title":"How it Works","text":"<p>GATE is designed specifically for machine learning (ML) pipelines, where there may be many features and prediction columns. While other methods to detect drift may result in large numbers of false positives, GATE is designed to be more robust to this problem through the use of partition summaries.</p>"},{"location":"how-it-works/#partition-summarization","title":"Partition Summarization","text":"<p>GATE ingests raw data and computes a partition summary for each partition. A partition summary is a vector of statistical measures that captures the distribution of the data in the partition. Partitions are typically time-based; for example, one per day. The following statistics are computed for each column:</p> <ul> <li>coverage: The fraction of the column that has non-null values.</li> <li>mean: The mean of the column.</li> <li>p50: The median of the column.</li> <li>num_unique_values: The number of unique values in the column.</li> <li>occurrence_ratio: The count of the most frequent value divided by the total count.</li> <li>p95: The 95th percentile of the column.</li> </ul> <p>Partition summaries are small, and can be computed quickly. They are also robust to outliers, which is important for ML pipelines where there may be many features and prediction columns.</p>"},{"location":"how-it-works/#drift-detection","title":"Drift Detection","text":"<p>The partition summaries are then fed into an anomaly detection algorithm to detect whether a new partition is anomalous.</p>"},{"location":"how-it-works/#clustering","title":"Clustering","text":"<p>Since many columns might be correlated, GATE first clusters the columns into groups. GATE considers both the semantic meaning of the column (e.g., \"age\" and \"income\") and the partition summaries.</p> <p>Clustering is automatically performed by the GATE algorithm. The user does not need to specify the number of clusters. Partition summaries are normalized via z-score before clustering, so that the clustering algorithm is not biased towards columns with larger values.</p> <p>Note</p> <p>Clustering is engaged if there are more than 10 columns. If there are fewer than 10 columns, no clustering is performed.</p>"},{"location":"how-it-works/#nearest-neighbor-algorithm","title":"Nearest Neighbor Algorithm","text":"<p>Normalized partition summaries are then fed into a nearest neighbor algorithm to detect whether a new partition is anomalous. The nearest neighbor algorithm is a variant of the k-nearest neighbors algorithm. The algorithm computes the distance between the new partition and the nearest neighbors in previous partition summaries. If the distance is large (i.e., in the 90th percentile of distances), the new partition is considered drifted.</p> <p>Note</p> <p>If clustering is engaged, column summaries are averaged within each cluster before computing distances. This essentially reduces the dimensionality of the partition summary.</p>"},{"location":"how-it-works/#drill-down","title":"Drill Down","text":"<p>If a partition is detected as drifted, GATE can be used to drill down into the partition to identify the specific columns that are drifted. The columns with the largest z-score values are returned.</p>"},{"location":"how-it-works/#differences-from-the-original-research-paper","title":"Differences from the original research paper","text":"<p>Differences from the original implementation include:</p> <ul> <li>Removal of the need to specify a window size to normalize statistics over.</li> <li>Removal of the Wasserstein-1 distance and num_frequent_values metrics, which are time-consuming to compute and not as useful as other metrics.</li> <li>Addition of the p95 metric.</li> <li>Embeddings of column names and types in the clustering algorithm (in addition to partition summaries).</li> <li>Support for drift detection on embedding columns and computing drifted clusters.</li> </ul>"}]}